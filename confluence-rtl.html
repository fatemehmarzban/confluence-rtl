<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Direction Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        .editor-container {
            border: 2px solid #ccc;
            padding: 10px;
            min-height: 200px;
            width: 80%;
            background: #f9f9f9;
        }

        p, li {
            margin: 5px 0;
        }
    </style>
</head>
<body>

    <h2>Test Auto Direction Script</h2>
    <h3>تست است</h3>
    <!--<p>Type in the editor below. The text direction should change dynamically!</p>-->

    <div id="main-content" class="editor-container" contenteditable="true">
        <p>Start typing here...</p>
        <ul>
            <li>تست 1</li>
            <li>تست 2</li>
            <li>Test 3</li>
        </ul>
        <p>یا این یک مثال دیگر است</p>
        <ol>
            <li>Test 1</li>
            <li>تست 2</li>
            <li>تست 3</li>
            <li>Test 4</li>
        </ol>
    </div>

    <script>

        const tagIgnore = new Set(["CODE", "SCRIPT", "PRE"]);
        const inlineElements = new Set(["STRONG", "A"]);
        const listElements = new Set(["UL", "OL"]);

        function containsPersianChars(char) {
            var persianRegex = /[\u0600-\u06FF\u0750-\u077F]/;
            return persianRegex.test(char);
        }

        function findFirstNonInlineParent (element) {
            // Returns the element itself if the element display is not inline or inline-block
            var display = getComputedStyle(element)?.display;
            var parent = element;
            while (parent && (display === 'inline' || display === 'inline-block')) {
                parent = parent.parentElement;
                display = getComputedStyle(parent)?.display
            }
            return parent;
        }

        function setStyle(element, style) {
            
            var targetElement = element;

            if (!targetElement) {
                // console.log("---------- Returning!");
                return;
            }

            // console.log("---------- setStyle requested for " + element.nodeName + " with style " + style);

            // console.log("---------- Element is " + element.nodeName + " and style is: " + style);
            // console.log(element);

            if (inlineElements.has(element.nodeName)) {
                // console.log("---------- Inline Element is " + element.nodeName + " and style is: " + style);
                targetElement.style.setProperty("direction", style);
                targetElement.style.setProperty("display", "inline-block");

                setStyle(findFirstNonInlineParent(targetElement), style);

                /*if (style === "rtl") {
                    var parent = findFirstNonInlineParent(targetElement);
                    parent?.style.setProperty("direction", "rtl");
                    parent?.style.setProperty("text-align", "right");
                }*/

                return;
            }

            var targetElementDisplay = getComputedStyle(targetElement)?.display;

            // console.log("---------- display: " + targetElementDisplay);

            // console.log("---------- Parent: ");
            // console.log(targetElement.parentElement);

            targetElement = findFirstNonInlineParent(targetElement);

            /*while (targetElement && (targetElementDisplay === 'inline' || targetElementDisplay === 'inline-block')) {
                targetElement = targetElement.parentElement;
                targetElementDisplay = getComputedStyle(targetElement)?.display

                // console.log("---------- New Parent: ");
                // console.log(targetElement);
                // console.log("---------- display: " + getComputedStyle(targetElement)?.display + " and direction: " + getComputedStyle(targetElement)?.direction);
            }*/
            // console.log("---------- Final Parent: ");
            // console.log(targetElement);
            // console.log("---------- display: " + getComputedStyle(targetElement)?.display + " and direction: " + getComputedStyle(targetElement)?.direction);

            if (targetElement && targetElement?.nodeName !== "LI") {
                // console.log("---------- targetElement is " + targetElement.nodeName + " and is not LI");

                if (targetElement.parentElement.nodeName === "LI") {
                    // It still might be a list child.
                    // console.log("---------- Setting direction to inherit");
                    targetElement.style.setProperty("direction", "inherit");
                    targetElement.style.setProperty("text-align", "inherit");
                    targetElement.style.setProperty("padding-inline-end", "40px");
                    setStyle(targetElement.parentElement, style);
                    return;
                }

                if (getComputedStyle(targetElement)?.direction === "rtl" && style === "ltr") {
                    // console.log("---------- not setting anything!");
                    return; 
                } else /*if (getComputedStyle(targetElement)?.direction === "ltr" && style === "ltr")*/ {
                    // console.log("---------- Setting " + style);
                    targetElement.style.setProperty("direction", style);
                    targetElement.style.setProperty("text-align", style == "rtl" ? "right" : "left"); 
                }

            } else if (targetElement && targetElement.nodeName === "LI" && listElements.has(targetElement.parentElement.nodeName)) {

                // console.log("---------- parent is " + targetElement.parentElement.nodeName + " and direction is " + getComputedStyle(targetElement?.parentElement)?.direction);

                if (style === "rtl") {
                    // console.log("---------- Setting style rtl for the element and its parent");
                    
                    targetElement.style.setProperty("direction", "inherit");
                    targetElement.style.setProperty("text-align", "inherit");
                    targetElement.style.setProperty("padding-inline-end", "40px");

                    targetElement.parentElement.style.setProperty("direction", "rtl");
                    targetElement.parentElement.style.setProperty("text-align", "right");
                    targetElement.parentElement.style.setProperty("padding-inline-end", "40px");
                } else if (style === "ltr") {
                    // console.log("---------- Setting style ltr just for the element");
                    targetElement.style.setProperty("direction", "inherit");
                    targetElement.style.setProperty("text-align", "inherit");
                    targetElement.style.setProperty("padding-inline-end", "40px");
                }
            }
        }

        function setDirection(rootElement) {

            if (!rootElement) {
                return;
            }
            // console.log("---------- setDirection called for " + rootElement.nodeName);
            var textElements = rootElement.querySelectorAll(":not(:empty)");

            if (!textElements.length) {
                // console.log(rootElement.nodeName + " has no children.");
                return;
            }

            textElements.forEach(textElement => {

                if (tagIgnore.has(textElement.nodeName)) {
                    // console.log("--------- Ignoring tag " + textElement.nodeName);
                    return;
                }
                if (textElement.getAttribute("class")?.includes("code")) {
                    // console.log("--------- Code table in textElements loop. Skipping");
                    return; // This is a code block and skip it
                }
                if (textElement.nodeType === Node.ELEMENT_NODE) {
                    textElement.childNodes.forEach(child => {
                        if (child.nodeType === 3) { // Text Node
                            // console.log("---------- Checking:");
                            // console.log(child);
                            var firstChar = child.nodeValue.trim().match(/[A-Za-z\u0600-\u06FF\u0750-\u077F]/);
                            // console.log(firstChar);
                            // if (firstChar && containsPersianChars(firstChar)) {
                            // console.log("---------- child is " + child.nodeName + " and has the value: " + child.nodeValue.trim());
                            // console.log(child.nodeValue);  // Logs the raw content
                            // console.log([...child.nodeValue].map(c => c.charCodeAt(0).toString(16))); // Logs the character codes in hexadecimal
                            // console.log("---------- comparison: " + child.nodeValue.trim() === '\u00A0');
                            // console.log("---------- comparison: " + child.nodeValue.trim() === "&nbsp;");
                            // console.log("---------- comparison: " + child.nodeValue.charCodeAt(0) === 0xA0);

                            // if (child.nodeValue.charCodeAt(0) === 0xA0) { // It is a &nbsp or a space;
                            if (/^[\s\u00A0]$/.test(child.nodeValue) || !firstChar) { // It is all &nbsp, spaces or special characters;
                                // console.log("---------- Returning, only spaces!");
                                return;
                            }

                            if (containsPersianChars(child.nodeValue.trim())) {
                                // console.log("---------- Setting RTL style for");
                                // console.log(child);
                                setStyle(textElement, "rtl");
                            } else {
                                // console.log("---------- Setting LTR style for");
                                // console.log(child);
                                setStyle(textElement, "ltr");
                            }
                        }
                    });
                }
            });

            var tables = rootElement.querySelectorAll("table");
            tables.forEach((table) => {
                if (table.getAttribute("data-macro-name") !== "code") {
                    // console.log("--------- Code data-macro-name in table loop. Skipping");
                    return; // Skip this table
                }
                if (table.querySelector("td.code")) {
                    // console.log("--------- Code table in tables loop. Skipping");
                    return; // Skip this table
                }
                var firstTh = table.querySelector("th:first-child");
                if (firstTh) {
                    // console.log("---------- First TH:");
                    // console.log(firstTh);
                    var firstChar = firstTh.textContent.trim().match(/[A-Za-z\u0600-\u06FF\u0750-\u077F]/);

                    // if (firstChar && containsPersianChars(firstChar[0])) {
                    if (firstChar && containsPersianChars(firstTh.textContent.trim())) {
                        table.style.setProperty("direction", "rtl");
                        table.style.setProperty("margin-left", "auto");
                    } else {
                        table.style.setProperty("direction", "ltr");
                    }
                }
            });
        }

        function handleIframe(iframe) {
            iframe.addEventListener("load", function () {
                var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
                var iframeBody = iframeDocument.querySelector("body");

                if (!iframeDocument || !iframeBody) {
                    return;
                }

                // Apply styles initially
                setDirection(iframeBody);

                // Observe changes inside iframe body
                const iframeObserver = new MutationObserver(mutations => {
                    mutations.forEach(mutation => {
                        // console.log("---------- Mutation on " + mutation.target.nodeName + " with parent " + mutation.target.parentElement.nodeName);
                        if (tagIgnore.has(mutation.target.parentElement?.nodeName)) {
                            // console.log("---------- Ignoring." + mutation.target.nodeName);
                            return; // Ignore mutations on specified tags
                        }
                        // console.log("---------- Mutation Type: " + mutation.type);
                        // console.log("---------- Mutation Target: " + mutation.target.nodeName);
                        if (mutation.type === "characterData") {
                            // console.log("Character data changed in:", mutation.target);
                            var firstChar = mutation.target.textContent.trim().match(/[A-Za-z\u0600-\u06FF\u0750-\u077F]/);
                            if (firstChar && containsPersianChars(mutation.target.textContent.trim())) {
                                setStyle(mutation.target.parentElement, "rtl");
                            } else {
                                setStyle(mutation.target.parentElement, "ltr");
                            }
                            
                        }
                    });
                });

                iframeObserver.observe(iframeBody, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });

            });
        }

        // Observe DOM changes to detect edit mode and added iframe
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeName === "IFRAME") {
                        // console.log("---------- IFRAME Found!");
                        handleIframe(node);
                    }
                });
            });
        });

        // Start observing
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        var pageContent = document.querySelector("div#main-content");

        window.onload = function () {
            setTimeout(() => setDirection(pageContent), 700);
            setDirection(pageContent);
        };

    </script>

</body>
</html>
