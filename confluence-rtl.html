<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Direction Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        .editor-container {
            border: 2px solid #ccc;
            padding: 10px;
            min-height: 200px;
            width: 80%;
            background: #f9f9f9;
        }

        p, li {
            margin: 5px 0;
        }
    </style>
</head>
<body>

    <h2>Test Auto Direction Script</h2>
    <h3>تست است</h3>
    <!--<p>Type in the editor below. The text direction should change dynamically!</p>-->

    <div id="main-content" class="editor-container" contenteditable="true">
        <p>Start typing here...</p>
        <ul>
            <li>تست 1</li>
            <li>تست 2</li>
            <li>Test 3</li>
        </ul>
        <p>یا این یک مثال دیگر است</p>
        <ol>
            <li>Test 1</li>
            <li>تست 2</li>
            <li>تست 3</li>
            <li>Test 4</li>
        </ol>
    </div>

    <script>
        function isPersianChar(char) {
            var persianRegex = /[\u0600-\u06FF\u0750-\u077F]/;
            return persianRegex.test(char);
        }

        function setStyle(element, style) {
            // console.log("---------- setStyle requested for " + element.nodeName + " with style " + style);
            
            var targetElement = element;
            var parentDirection = getComputedStyle(targetElement.parentElement).direction;
            // var paddingInline = parentDirection == "rtl" ? "padding-inline-start: 40px;" : "padding-inline-end: 40px";
            const rtlStyle = "direction:rtl; text-align:right;";
            const ltrStyle = "direction:ltr; text-align:left;";
            // const liStyle = "direction:inherit; text-align:inherit; " + paddingInline;
            const liStyle = "direction:inherit; text-align:inherit; padding-inline-end: 40px;";
            const olRtlStyle = "direction:rtl; text-align:right; padding-inline-end: 40px;";
            
            if (!targetElement) {
                return;
            }
            while (targetElement && getComputedStyle(targetElement).display === 'inline') {
                targetElement = targetElement.parentElement;
            }
            if (targetElement && targetElement.nodeName !== "LI") {
                // console.log("---------- targetElement is " + targetElement.nodeName + " and is not LI");
                targetElement.setAttribute("style", style == "rtl" ? rtlStyle : ltrStyle);

            } else if (targetElement.nodeName === "LI" && (targetElement.parentElement.nodeName === "UL" || targetElement.parentElement.nodeName === "OL")) {

                // console.log("---------- targetElement is " + targetElement.nodeName);
                // console.log("---------- parent is " + targetElement.parentElement.nodeName + " and direction is " + parentDirection);

                if (style === "rtl") {
                    // console.log("---------- Setting style rtl for the element and its parent");
                    targetElement.setAttribute("style", liStyle);
                    targetElement.parentElement.setAttribute("style", olRtlStyle);
                } else if (style === "ltr") {
                    // console.log("---------- Setting style ltr just for the element");
                    targetElement.setAttribute("style",  liStyle);
                }
            }
        }

        function setDirection(rootElement) {

            if (!rootElement) {
                return;
            }
            // console.log("---------- setDirection called for " + rootElement.nodeName);
            var textElements = rootElement.querySelectorAll(":not(:empty)");

            if (!textElements.length) {
                // console.log(rootElement.nodeName + " has no children.");
                return;
                // setStyle(rootElement, "rtl");
            }

            textElements.forEach(textElement => {
                if (textElement.nodeType === Node.ELEMENT_NODE && textElement.nodeName !== "SCRIPT") {
                    textElement.childNodes.forEach(child => {
                        if (child.nodeType === 3) { // Text Node
                            var firstChar = child.nodeValue.trim().match(/[A-Za-z\u0600-\u06FF\u0750-\u077F]/);
                            if (firstChar && isPersianChar(firstChar)) {
                                setStyle(textElement, "rtl");
                            } else {
                                setStyle(textElement, "ltr");
                            }
                        }
                    });
                }
            });

            var tables = rootElement.querySelectorAll("table");
            tables.forEach((table) => {
                var firstTh = table.querySelector("th:first-child");
                if (firstTh) {
                    var firstChar = firstTh.textContent.trim().match(/[A-Za-z\u0600-\u06FF\u0750-\u077F]/);
                    if (firstChar && isPersianChar(firstChar[0])) {
                        table.setAttribute("style", "direction:rtl; margin-left:auto");
                    } else {
                        table.setAttribute("style", "direction:ltr;");
                    }
                }
            });
        }

        function handleIframe(iframe) {
            iframe.addEventListener("load", function () {
                var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
                var iframeBody = iframeDocument.querySelector("body");

                if (!iframeDocument || !iframeBody) {
                    return;
                }

                // Apply styles initially
                setDirection(iframeBody);

                // Observe changes inside iframe body
                const iframeObserver = new MutationObserver(mutations => {
                    mutations.forEach(mutation => {
                        // console.log("---------- Mutation Type: " + mutation.type);
                        // console.log("---------- Mutation Target: " + mutation.target.nodeName);
                        if (mutation.type === "characterData") {
                            // console.log("Character data changed in:", mutation.target);
                            var firstChar = mutation.target.textContent.trim().match(/[A-Za-z\u0600-\u06FF\u0750-\u077F]/);
                            if (firstChar && isPersianChar(firstChar[0])) {
                                setStyle(mutation.target.parentElement, "rtl");
                            } else {
                                setStyle(mutation.target.parentElement, "ltr");
                            }
                            
                        }
                    });
                });

                iframeObserver.observe(iframeBody, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });

            });
        }

        // Observe DOM changes to detect edit mode and added iframe
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeName === "IFRAME") {
                        // console.log("---------- IFRAME Found!");
                        handleIframe(node);
                    }
                });
            });
        });

        // Start observing
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });

        var pageContent = document.querySelector("div#content");

        window.onload = function () {
            setTimeout(() => setDirection(pageContent), 700);
            setDirection(pageContent);
        };

    </script>

</body>
</html>
